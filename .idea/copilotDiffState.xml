<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/oguzhanozgokce/androidbootcampfinalproject/data/repository/GameScoreRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/oguzhanozgokce/androidbootcampfinalproject/data/repository/GameScoreRepositoryImpl.kt" />
              <option name="originalContent" value="package com.oguzhanozgokce.androidbootcampfinalproject.data.repository&#10;&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.oguzhanozgokce.androidbootcampfinalproject.common.exception.ErrorHandler&#10;import com.oguzhanozgokce.androidbootcampfinalproject.common.safeCall&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.mapper.toDomainList&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.mapper.toDto&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.model.GameCardDto&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.model.GameScoreDto&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.model.GameScore&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.repository.GameScoreRepository&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;&#10;class GameScoreRepositoryImpl @Inject constructor(&#10;    private val firestore: FirebaseFirestore&#10;) : GameScoreRepository {&#10;&#10;    companion object {&#10;        private const val COLLECTION_SCORES = &quot;game_scores&quot;&#10;    }&#10;&#10;    override suspend fun saveScore(gameScore: GameScore): Result&lt;String&gt; = safeCall {&#10;        val scoreDto = gameScore.toDto()&#10;        val docRef = if (scoreDto.id.isNullOrEmpty()) {&#10;            firestore.collection(COLLECTION_SCORES).document()&#10;        } else {&#10;            firestore.collection(COLLECTION_SCORES).document(scoreDto.id)&#10;        }&#10;&#10;        val scoreWithId = scoreDto.copy(id = docRef.id)&#10;        docRef.set(scoreWithId).await()&#10;        docRef.id&#10;    }&#10;&#10;    override suspend fun getAllScores(): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        throw Exception(&quot;getCurrentUserId() method needed - implement with AuthRepository&quot;)&#10;    }&#10;&#10;    override suspend fun getAllScoresByUserId(userId: String): Result&lt;List&lt;GameScore&gt;&gt; {&#10;        return try {&#10;            val snapshot = firestore.collection(COLLECTION_SCORES)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .get()&#10;                .await()&#10;                .await()&#10;            val scores = snapshot.documents.mapNotNull { doc -&gt;&#10;                doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;            }.toDomainList().sortedByDescending { it.score }&#10;&#10;            Result.success(scores)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;            }.toDomainList().sortedByDescending { it.score }&#10;&#10;            Result.success(scores)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun getTopScores(limit: Int): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .get()&#10;            .await()&#10;&#10;        snapshot.documents.mapNotNull { doc -&gt;&#10;            doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;        }.toDomainList()&#10;            .sortedByDescending { it.score }&#10;            .take(limit)&#10;    }&#10;&#10;    override suspend fun getTopScoresByUserId(userId: String, limit: Int): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .get()&#10;            .await()&#10;&#10;        snapshot.documents.mapNotNull { doc -&gt;&#10;            doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;        }.toDomainList()&#10;            .sortedByDescending { it.score }&#10;            .take(limit)&#10;    }&#10;&#10;    override suspend fun deleteScore(scoreId: String): Result&lt;Unit&gt; = safeCall {&#10;        firestore.collection(COLLECTION_SCORES)&#10;            .document(scoreId)&#10;            .delete()&#10;            .await()&#10;    }&#10;&#10;    override suspend fun clearAllScores(): Result&lt;Unit&gt; = safeCall {&#10;        throw Exception(&quot;clearAllScoresByUserId() method should be used instead&quot;)&#10;    }&#10;&#10;    override suspend fun clearAllScoresByUserId(userId: String): Result&lt;Unit&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .get()&#10;            .await()&#10;&#10;        val batch = firestore.batch()&#10;        snapshot.documents.forEach { doc -&gt;&#10;            batch.delete(doc.reference)&#10;        }&#10;        batch.commit().await()&#10;    }&#10;&#10;    override fun getScoresFlow(): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt; = callbackFlow {&#10;        throw Exception(&quot;getScoresFlowByUserId() method should be used instead&quot;)&#10;    }&#10;&#10;    override fun getScoresFlowByUserId(userId: String): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt; = callbackFlow {&#10;        val listener = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null) {&#10;                    val errorMessage = ErrorHandler.handleException(error)&#10;                    trySend(Result.failure(Exception(errorMessage)))&#10;                    return@addSnapshotListener&#10;                }&#10;&#10;                if (snapshot != null) {&#10;                    val scores = snapshot.documents.mapNotNull { doc -&gt;&#10;                        doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;                    }.toDomainList()&#10;                        .sortedByDescending { it.score } // Client-side sorting&#10;                    trySend(Result.success(scores))&#10;                }&#10;            }&#10;&#10;        awaitClose { listener.remove() }&#10;    }&#10;&#10;    /**&#10;     * Oyun için rastgele sayıları Firebase'den çekmek için&#10;     */&#10;    override suspend fun getRandomNumbers(count: Int): Result&lt;List&lt;Int&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(&quot;game_numbers&quot;)&#10;            .limit(100)&#10;            .get()&#10;            .await()&#10;&#10;        val allNumbers = snapshot.documents.mapNotNull { doc -&gt;&#10;            val gameCardDto = doc.toObject(GameCardDto::class.java)&#10;            gameCardDto?.number&#10;        }&#10;&#10;        val result = if (allNumbers.isEmpty()) {&#10;            (1..100).shuffled().take(count)&#10;        } else {&#10;            allNumbers.shuffled().take(count)&#10;        }&#10;        result&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.oguzhanozgokce.androidbootcampfinalproject.data.repository&#10;&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.oguzhanozgokce.androidbootcampfinalproject.common.exception.ErrorHandler&#10;import com.oguzhanozgokce.androidbootcampfinalproject.common.safeCall&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.mapper.toDomainList&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.mapper.toDto&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.model.GameCardDto&#10;import com.oguzhanozgokce.androidbootcampfinalproject.data.model.GameScoreDto&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.model.GameScore&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.repository.GameScoreRepository&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;&#10;class GameScoreRepositoryImpl @Inject constructor(&#10;    private val firestore: FirebaseFirestore&#10;) : GameScoreRepository {&#10;&#10;    companion object {&#10;        private const val COLLECTION_SCORES = &quot;game_scores&quot;&#10;    }&#10;&#10;    override suspend fun saveScore(gameScore: GameScore): Result&lt;String&gt; = safeCall {&#10;        val scoreDto = gameScore.toDto()&#10;        val docRef = if (scoreDto.id.isNullOrEmpty()) {&#10;            firestore.collection(COLLECTION_SCORES).document()&#10;        } else {&#10;            firestore.collection(COLLECTION_SCORES).document(scoreDto.id)&#10;        }&#10;&#10;        val scoreWithId = scoreDto.copy(id = docRef.id)&#10;        docRef.set(scoreWithId).await()&#10;        docRef.id&#10;    }&#10;&#10;    override suspend fun getAllScores(): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        throw Exception(&quot;getCurrentUserId() method needed - implement with AuthRepository&quot;)&#10;    }&#10;&#10;    override suspend fun getAllScoresByUserId(userId: String): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .get()&#10;            .await()&#10;&#10;        snapshot.documents.mapNotNull { doc -&gt;&#10;            doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;        }.toDomainList().sortedByDescending { it.score }&#10;    }&#10;&#10;    override suspend fun getTopScores(limit: Int): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .get()&#10;            .await()&#10;&#10;        snapshot.documents.mapNotNull { doc -&gt;&#10;            doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;        }.toDomainList()&#10;            .sortedByDescending { it.score }&#10;            .take(limit)&#10;    }&#10;&#10;    override suspend fun getTopScoresByUserId(userId: String, limit: Int): Result&lt;List&lt;GameScore&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .get()&#10;            .await()&#10;&#10;        snapshot.documents.mapNotNull { doc -&gt;&#10;            doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;        }.toDomainList()&#10;            .sortedByDescending { it.score }&#10;            .take(limit)&#10;    }&#10;&#10;    override suspend fun deleteScore(scoreId: String): Result&lt;Unit&gt; = safeCall {&#10;        firestore.collection(COLLECTION_SCORES)&#10;            .document(scoreId)&#10;            .delete()&#10;            .await()&#10;    }&#10;&#10;    override suspend fun clearAllScores(): Result&lt;Unit&gt; = safeCall {&#10;        throw Exception(&quot;clearAllScoresByUserId() method should be used instead&quot;)&#10;    }&#10;&#10;    override suspend fun clearAllScoresByUserId(userId: String): Result&lt;Unit&gt; = safeCall {&#10;        val snapshot = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .get()&#10;            .await()&#10;&#10;        val batch = firestore.batch()&#10;        snapshot.documents.forEach { doc -&gt;&#10;            batch.delete(doc.reference)&#10;        }&#10;        batch.commit().await()&#10;    }&#10;&#10;    override fun getScoresFlow(): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt; = callbackFlow {&#10;        throw Exception(&quot;getScoresFlowByUserId() method should be used instead&quot;)&#10;    }&#10;&#10;    override fun getScoresFlowByUserId(userId: String): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt; = callbackFlow {&#10;        val listener = firestore.collection(COLLECTION_SCORES)&#10;            .whereEqualTo(&quot;userId&quot;, userId)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null) {&#10;                    val errorMessage = ErrorHandler.handleException(error)&#10;                    trySend(Result.failure(Exception(errorMessage)))&#10;                    return@addSnapshotListener&#10;                }&#10;&#10;                if (snapshot != null) {&#10;                    val scores = snapshot.documents.mapNotNull { doc -&gt;&#10;                        doc.toObject(GameScoreDto::class.java)?.copy(id = doc.id)&#10;                    }.toDomainList()&#10;                        .sortedByDescending { it.score } // Client-side sorting&#10;                    trySend(Result.success(scores))&#10;                }&#10;            }&#10;&#10;        awaitClose { listener.remove() }&#10;    }&#10;&#10;    /**&#10;     * Oyun için rastgele sayıları Firebase'den çekmek için&#10;     */&#10;    override suspend fun getRandomNumbers(count: Int): Result&lt;List&lt;Int&gt;&gt; = safeCall {&#10;        val snapshot = firestore.collection(&quot;game_numbers&quot;)&#10;            .limit(100)&#10;            .get()&#10;            .await()&#10;&#10;        val allNumbers = snapshot.documents.mapNotNull { doc -&gt;&#10;            val gameCardDto = doc.toObject(GameCardDto::class.java)&#10;            gameCardDto?.number&#10;        }&#10;&#10;        val result = if (allNumbers.isEmpty()) {&#10;            (1..100).shuffled().take(count)&#10;        } else {&#10;            allNumbers.shuffled().take(count)&#10;        }&#10;        result&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/oguzhanozgokce/androidbootcampfinalproject/domain/repository/GameScoreRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/oguzhanozgokce/androidbootcampfinalproject/domain/repository/GameScoreRepository.kt" />
              <option name="originalContent" value="package com.oguzhanozgokce.androidbootcampfinalproject.domain.repository&#10;&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.model.GameScore&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface GameScoreRepository {&#10;    suspend fun saveScore(gameScore: GameScore): Result&lt;String&gt;&#10;    suspend fun getAllScores(): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun getAllScoresByUserId(userId: String): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun getTopScores(limit: Int = 20): List&lt;GameScore&gt;&#10;    suspend fun getTopScoresByUserId(userId: String, limit: Int = 10): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun deleteScore(scoreId: String): Result&lt;Unit&gt;&#10;    suspend fun clearAllScores(): Result&lt;Unit&gt;&#10;    suspend fun clearAllScoresByUserId(userId: String): Result&lt;Unit&gt;&#10;    fun getScoresFlow(): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt;&#10;    fun getScoresFlowByUserId(userId: String): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt;&#10;    suspend fun getRandomNumbers(count: Int): Result&lt;List&lt;Int&gt;&gt;&#10;}" />
              <option name="updatedContent" value="package com.oguzhanozgokce.androidbootcampfinalproject.domain.repository&#10;&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.model.GameScore&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface GameScoreRepository {&#10;    suspend fun saveScore(gameScore: GameScore): Result&lt;String&gt;&#10;    suspend fun getAllScores(): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun getAllScoresByUserId(userId: String): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun getTopScores(limit: Int = 20): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun getTopScoresByUserId(userId: String, limit: Int = 10): Result&lt;List&lt;GameScore&gt;&gt;&#10;    suspend fun deleteScore(scoreId: String): Result&lt;Unit&gt;&#10;    suspend fun clearAllScores(): Result&lt;Unit&gt;&#10;    suspend fun clearAllScoresByUserId(userId: String): Result&lt;Unit&gt;&#10;    fun getScoresFlow(): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt;&#10;    fun getScoresFlowByUserId(userId: String): Flow&lt;Result&lt;List&lt;GameScore&gt;&gt;&gt;&#10;    suspend fun getRandomNumbers(count: Int): Result&lt;List&lt;Int&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/oguzhanozgokce/androidbootcampfinalproject/ui/settings/SettingsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/oguzhanozgokce/androidbootcampfinalproject/ui/settings/SettingsViewModel.kt" />
              <option name="originalContent" value="package com.oguzhanozgokce.androidbootcampfinalproject.ui.settings&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.oguzhanozgokce.androidbootcampfinalproject.delegation.MVI&#10;import com.oguzhanozgokce.androidbootcampfinalproject.delegation.mvi&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.ClearScoresUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.GetCurrentUserUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.GetGameSettingsUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.UpdateThemeUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.UpdateTimerUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.ui.settings.SettingsContract.UiAction&#10;import com.oguzhanozgokce.androidbootcampfinalproject.ui.settings.SettingsContract.UiEffect&#10;import com.oguzhanozgokce.androidbootcampfinalproject.ui.settings.SettingsContract.UiState&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class SettingsViewModel @Inject constructor(&#10;    private val getGameSettingsUseCase: GetGameSettingsUseCase,&#10;    private val updateThemeUseCase: UpdateThemeUseCase,&#10;    private val updateTimerUseCase: UpdateTimerUseCase,&#10;    private val clearScoresUseCase: ClearScoresUseCase,&#10;    private val getCurrentUserUseCase: GetCurrentUserUseCase&#10;) : ViewModel(), MVI&lt;UiState, UiAction, UiEffect&gt; by mvi(UiState()) {&#10;&#10;    private var currentUserId: String = &quot;&quot;&#10;&#10;    init {&#10;        loadSettings()&#10;    }&#10;&#10;    private fun loadSettings() {&#10;        viewModelScope.launch {&#10;            getCurrentUserUseCase().onSuccess { user -&gt;&#10;                user?.let { currentUser -&gt;&#10;                    currentUserId = currentUser.uid&#10;                    getGameSettingsUseCase.flow(currentUserId).collectLatest { result -&gt;&#10;                        result.onSuccess { settings -&gt;&#10;                            val currentState = this@SettingsViewModel.uiState.value&#10;                            updateUiState {&#10;                                copy(&#10;                                    gameSettings = settings,&#10;                                    isLoading = false,&#10;                                    currentTheme = currentState.currentTheme ?: settings.isDarkTheme,&#10;                                    currentTimer = currentState.currentTimer ?: settings.isTimerEnabled&#10;                                )&#10;                            }&#10;                        }.onFailure { error -&gt;&#10;                            updateUiState { copy(isLoading = false) }&#10;                            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Ayarlar yüklenemedi&quot;))&#10;                        }&#10;                    }&#10;                } ?: run {&#10;                    updateUiState { copy(isLoading = false) }&#10;                    emitUiEffect(UiEffect.ShowError(&quot;Kullanıcı oturum açmamış&quot;))&#10;                }&#10;            }.onFailure { error -&gt;&#10;                updateUiState { copy(isLoading = false) }&#10;                emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Kullanıcı bulunamadı&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAction(uiAction: UiAction) {&#10;        viewModelScope.launch {&#10;            when (uiAction) {&#10;                is UiAction.ToggleTheme -&gt; handleToggleTheme(uiAction.isDarkTheme)&#10;                is UiAction.ToggleTimer -&gt; handleToggleTimer(uiAction.isTimerEnabled)&#10;                UiAction.ShowClearScoresDialog -&gt; updateUiState { copy(showClearScoresDialog = true) }&#10;                UiAction.HideClearScoresDialog -&gt; updateUiState { copy(showClearScoresDialog = false) }&#10;                UiAction.ClearScores -&gt; handleClearScores()&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleToggleTheme(isDarkTheme: Boolean) {&#10;       updateUiState { copy(currentTheme = isDarkTheme) }&#10;&#10;        updateThemeUseCase(currentUserId, isDarkTheme).onSuccess {&#10;            emitUiEffect(UiEffect.ThemeUpdated)&#10;        }.onFailure { error -&gt;&#10;            updateUiState { copy(currentTheme = !isDarkTheme) }&#10;            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Tema güncellenemedi&quot;))&#10;        }&#10;    }&#10;&#10;    private suspend fun handleToggleTimer(isTimerEnabled: Boolean) {&#10;        updateUiState { copy(currentTimer = isTimerEnabled) }&#10;        updateTimerUseCase(currentUserId, isTimerEnabled).onSuccess {&#10;            emitUiEffect(UiEffect.TimerUpdated)&#10;        }.onFailure { error -&gt;&#10;            updateUiState { copy(currentTimer = !isTimerEnabled) }&#10;            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Timer ayarı güncellenemedi&quot;))&#10;        }&#10;    }&#10;&#10;    private suspend fun handleClearScores() {&#10;        clearScoresUseCase(currentUserId).onSuccess {&#10;            updateUiState { copy(showClearScoresDialog = false) }&#10;            emitUiEffect(UiEffect.ScoresCleared)&#10;        }.onFailure { error -&gt;&#10;            updateUiState { copy(showClearScoresDialog = false) }&#10;            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Skorlar temizlenemedi&quot;))&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.oguzhanozgokce.androidbootcampfinalproject.ui.settings&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.oguzhanozgokce.androidbootcampfinalproject.delegation.MVI&#10;import com.oguzhanozgokce.androidbootcampfinalproject.delegation.mvi&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.ClearScoresUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.GetCurrentUserUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.GetGameSettingsUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.UpdateThemeUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.domain.usecase.UpdateTimerUseCase&#10;import com.oguzhanozgokce.androidbootcampfinalproject.ui.settings.SettingsContract.UiAction&#10;import com.oguzhanozgokce.androidbootcampfinalproject.ui.settings.SettingsContract.UiEffect&#10;import com.oguzhanozgokce.androidbootcampfinalproject.ui.settings.SettingsContract.UiState&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class SettingsViewModel @Inject constructor(&#10;    private val getGameSettingsUseCase: GetGameSettingsUseCase,&#10;    private val updateThemeUseCase: UpdateThemeUseCase,&#10;    private val updateTimerUseCase: UpdateTimerUseCase,&#10;    private val clearScoresUseCase: ClearScoresUseCase,&#10;    private val getCurrentUserUseCase: GetCurrentUserUseCase&#10;) : ViewModel(), MVI&lt;UiState, UiAction, UiEffect&gt; by mvi(UiState()) {&#10;&#10;    private var currentUserId: String = &quot;&quot;&#10;&#10;    init {&#10;        loadSettings()&#10;    }&#10;&#10;    private fun loadSettings() {&#10;        viewModelScope.launch {&#10;            getCurrentUserUseCase().onSuccess { user -&gt;&#10;                user?.let { currentUser -&gt;&#10;                    currentUserId = currentUser.uid&#10;                    getGameSettingsUseCase.flow(currentUserId).collectLatest { result -&gt;&#10;                        result.onSuccess { settings -&gt;&#10;                            updateUiState {&#10;                                copy(&#10;                                    gameSettings = settings,&#10;                                    isLoading = false,&#10;                                    currentTheme = settings.isDarkTheme,&#10;                                    currentTimer = settings.isTimerEnabled&#10;                                )&#10;                            }&#10;                        }.onFailure { error -&gt;&#10;                            updateUiState { copy(isLoading = false) }&#10;                            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Ayarlar yüklenemedi&quot;))&#10;                        }&#10;                    }&#10;                } ?: run {&#10;                    updateUiState { copy(isLoading = false) }&#10;                    emitUiEffect(UiEffect.ShowError(&quot;Kullanıcı oturum açmamış&quot;))&#10;                }&#10;            }.onFailure { error -&gt;&#10;                updateUiState { copy(isLoading = false) }&#10;                emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Kullanıcı bulunamadı&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAction(uiAction: UiAction) {&#10;        viewModelScope.launch {&#10;            when (uiAction) {&#10;                is UiAction.ToggleTheme -&gt; handleToggleTheme(uiAction.isDarkTheme)&#10;                is UiAction.ToggleTimer -&gt; handleToggleTimer(uiAction.isTimerEnabled)&#10;                UiAction.ShowClearScoresDialog -&gt; updateUiState { copy(showClearScoresDialog = true) }&#10;                UiAction.HideClearScoresDialog -&gt; updateUiState { copy(showClearScoresDialog = false) }&#10;                UiAction.ClearScores -&gt; handleClearScores()&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleToggleTheme(isDarkTheme: Boolean) {&#10;       updateUiState { copy(currentTheme = isDarkTheme) }&#10;&#10;        updateThemeUseCase(currentUserId, isDarkTheme).onSuccess {&#10;            emitUiEffect(UiEffect.ThemeUpdated)&#10;        }.onFailure { error -&gt;&#10;            updateUiState { copy(currentTheme = !isDarkTheme) }&#10;            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Tema güncellenemedi&quot;))&#10;        }&#10;    }&#10;&#10;    private suspend fun handleToggleTimer(isTimerEnabled: Boolean) {&#10;        updateUiState { copy(currentTimer = isTimerEnabled) }&#10;        updateTimerUseCase(currentUserId, isTimerEnabled).onSuccess {&#10;            emitUiEffect(UiEffect.TimerUpdated)&#10;        }.onFailure { error -&gt;&#10;            updateUiState { copy(currentTimer = !isTimerEnabled) }&#10;            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Timer ayarı güncellenemedi&quot;))&#10;        }&#10;    }&#10;&#10;    private suspend fun handleClearScores() {&#10;        clearScoresUseCase(currentUserId).onSuccess {&#10;            updateUiState { copy(showClearScoresDialog = false) }&#10;            emitUiEffect(UiEffect.ScoresCleared)&#10;        }.onFailure { error -&gt;&#10;            updateUiState { copy(showClearScoresDialog = false) }&#10;            emitUiEffect(UiEffect.ShowError(error.message ?: &quot;Skorlar temizlenemedi&quot;))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>